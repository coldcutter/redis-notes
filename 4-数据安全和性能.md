# 4 数据安全和性能

## 4.1 持久化选项

Redis提供两种方式持久化数据到磁盘，一种是 _snapshotting_ ，保存某一时刻的数据到磁盘，另一种是 _append-only file_ \(AOF\)，把对Redis的写操作记录到磁盘。

![](/assets/QQ20160823-1.png)

### 4.1.1 快照

5种方法创建snapshot：

* BGSAVE命令，在支持BGSAVE的平台上（除了Windows），Redis会fork一个子进程来把快照写到磁盘，父进程继续响应命令。
* SAVE命令，使得Redis停止响应任何命令直到快照创建完毕，这个命令不常用，除非等待快照创建完成是ok的，或者没有足够的内存使用BGSAVE。
* save配置项，比如save 60 10000，表示如果从上次成功的save以来，60秒内出现了10000次写，Redis自动触发一个BGSAVE操作，如果有多条save选项，任意一条满足就会触发BGSAVE。
* 当Redis被请求关闭（SHUTDOWN命令）或接收一个标准的TERM信号，Redis执行一个SAVE，组织客户端执行任意命令，然后关闭。
* 如果一个Redis server连到另一个Redis server且发出一个SYNC命令开始执行 replication ，master Redis server会开始一个BGSAVE操作（如果没有正在执行BGSAVE操作或最近完成过）。

快照常用场景：开发，聚合日志，大数据

例子：在一个68G内存的云Xen虚拟机上，Redis使用了50G内存，使用BGSAVE（同时客户端还在写），fork需要15秒以上，快照创建完成需要15到20分钟，但是使用SAVE，快照只要3到5分钟就能创建完成，所以我们编写脚本使客户端停止访问Redis，调用SAVE，等待SAVE完成，然后通知客户端继续。

### 4.1.2 Append-only file

通过把数据写操作记录到文件，就可以通过操作重现来恢复数据集，可以通过appendonly yes启用。

![](/assets/QQ20160824-1.png)

文件同步（file sync）：当向磁盘写文件时，至少发生3件事，第一个是写到缓冲区（buffer），这发生在调用file.write\(\)（或其他语言对应语法）的时候。当数据在缓冲区时，操作系统会在未来的某个时间点把数据写到磁盘。我们可以（可选地）采取第二步，通过file.flush\(\)请求操作系统有机会的时候把数据写到磁盘，不过这仅仅只是请求，它会阻塞直到完成。

appendfsync always意味着每次写Redis都会导致写磁盘，性能就会受磁盘影响，普通磁盘每秒大约200次写，SSD大约上万次。

**WARNING: SSDS AND appendfsync always：**当使用SSD和always配置时，有可能导致称为write amplification（写入放大）的极端形式，写少量数据到文件结尾，在某些情况下可能缩减SSD寿命，从数年到几个月。

一般建议使用everysec，不推荐使用no，这会依赖操作系统，当写缓冲区满时，Redis会变得很慢因为被写阻塞了。

### 4.1.3 Rewriting\/compacting append-only files



